#' Function to produce simulated clusters
#'
#' \code{GRCsim} uses the Qiu and Joe 2006 algorithm implemented in
#' \code{\link[clusterGeneration]{genRandomClust}}to create simulated clusters with
#' clustering structure generated by two separate processes, one representing a
#' measured variable like membership in a cohort and another representing a
#' latent variable of interest such as disease state. This is done by generating
#' two clustered datasets, one with a specified separation by latent disease state
#' and another with a specified separation by cohort membership, and then adding
#' those datasets together. This function then changes some of the continuous
#' variables generated by the simulation algorithm into dichotomous categorical
#' variables (factors), thereby simulating mixed-type data.
#'
#' The simulated datasets generated by this function are then used to test the
#' ability of clustering algorithms in recovering the latent cluster structure
#' (disease state) that is partially obscured by the measured cluster structure
#' (e.g., clustering by cohort).
#'
#' @param nDisClust An integer of how many latent (disease state) clusters to
#' generate. Defaults to 2.
#' @param nCohortClust An integer of how many measured (cohort) clusters to
#' generate. Defaults to 2.
#' @param ncontvars An integer of how many continuous variables to generate.
#' Defaults to 2.
#' @param ncatvars An integer of how many dichotomous categorical variables to
#' generate. Defaults to 1.
#' @param DisSepVal A value between 0 and 1 reflecting the separation index
#' value for the latent disease state clusters (see
#' \code{?clusterGeneration::genRandomClust} for details). A higher value
#' indicates a greater separation. Defaults to 0.3.
#' @param CohortSepVal A value between 0 and 1 reflecting the separation index
#' value for the known cohort membership (see
#' \code{?clusterGeneration::genRandomClust} for details). A higher value
#' indicates a greater separation. Defaults to 0.15, which means that the
#' default settings indicate double the separation by disease state (0.3) as
#' compared to the separation by cohort membership (0.15).
#' @param catq A value between 0 and 1 representing the quantile at which
#' categorical variables are dichotomized. Defaults to 0.8, which means that
#' variables selected to be dichotomized will be 1 above the 80th percentile and
#' zero below, meaning a rate of 20% '1' responses.
#' @param nSignal The number of signal variables (defaults to 3). In this case,
#' signal variables indicate variables that impact the clustering.
#' @param nNoise The number of noise variables (defaults to 0). Noise variables
#' have no impact on the clustering. The sum of nSignal + nNoise must be equal
#' to the sum of ncontvars and ncatvars.
#' @param nOutliers The number of "outliers" (defaults to 0) as defined by
#' \code{\link[clusterGeneration]{genRandomClust}}, which generates this number
#' of outliers for each feature by choosing random values from a uniform
#' distribution bounded by 4 standard deviations below and above the mean of
#' each feature. These outliers are defined as belonging to a separate "0"
#' cluster for the "cohorts" (C0) and the "disease states" (D0).
#' @param nrep The number of clustered datasets to be generated (defaults to 50).
#' @param DisClustSizes A vector representing how many observations are in each
#' latent disease state cluster. Must be of the length defined in nDisClust.
#' Defaults to c(350, 150).
#' @param CohortClustSizes A vector representing how many observations are in
#' each cohort cluster. Must be of the length defined in nCohortClust. Defaults
#' to c(300, 200).
#' @param DisClustseed The random seed for the datasets clustered by latent
#' disease state. Defaults to 2.
#' @param CohortClustseed The random seed for the datasets clustered by cohort
#' membership. Defaults to 3.
#' @param CDS Boolean (logical) defining whether the "common data source" (CDS)
#' simulation condition should be applied to the simulated datasets. This
#' condition simulates a mixture of measured and latent variables being used to
#' simulate clusters, after which those latent variables would be split into
#' several correlated observed variables. This reflects the idea that some
#' multi-outcome measurements may be correlated and be imperfect measures of
#' latent variables driving clustering, such as there being several correlated
#' behavioral measures all reflecting some common condition like internalizing
#' behaviors. Defaults to \code{FALSE}. The specifics of this condition are
#' outlined in the next several parameters, which define how many continuous and
#' categorical "root" or latent variables there will be, which directly
#' contribute to the clustering. Then those latent variables are used to
#' generate a defined number of observed, correlated ("generated") variables.
#' @param nContCDSrootvars The number of continuous "root" CDS variables.
#' Defaults to 1 and is only relevant if CDS is set to TRUE.
#' @param nCatCDSrootvars The number of categorical "root" CDS variables.
#' Defaults to 1 and is only relevant if CDS is set to TRUE.
#' @param nContCDSgenvars The number of continuous "generated" CDS variables
#' created from each of the "root" variables. Defaults to 2 and is only relevant
#' if CDS is set to TRUE.
#' @param nCatCDSgenvars The number of categorical "generated" CDS variables
#' created from each of the "root" variables. Defaults to 2 and is only relevant
#' if CDS is set to TRUE.
#' @param CDSrho This is the Pearson correlation coefficient for the correlation
#' between each latent "root" variable in the CDS condition and each "generated"
#' variable. This is approximate, as there is some noise added to generate the
#' "generated" variables, but the true correlation between the latent variable
#' and the generated ones will be approximately this value. Defaults to 0.7.
#' Note that the correlation coefficient between the "generated" variables based
#' on the same "root" variable will be lower than this value. This is only
#' relevant if CDS is set to TRUE.
#' @param ratiomiss This is the ratio of missing:non-missing observations when
#' adding missingness to some variables. Defaults to 0.2, meaning that 20% of
#' each of the variables selected in \code{missindex} will be missing. This is
#' only relevant if \code{missindex} is specified.
#' @param missindex This is the index of variables selected to have missingness.
#' This index is in the context of the total number of variables (i.e.,
#' \code{ncontvars + ncatvars}), e.g., \code{c(1,3)} with the default settings
#' of \code{ncontvars=2} and \code{ncatvars = 1}. This defaults to \code{NULL},
#' which means that no missingness is added.
#' @param misstype This is one of "MCAR", "MAR", or "MNAR". Defaults to "MCAR".
#' If "MCAR", the row indices chosen for missingness are sampled at random. If
#' "MAR", the first principal component of all columns not selected with
#' \code{missindex} is used to determine missingness, with missing values being
#' sampled from rows corresponding to values of that principal component greater
#' than the quantile of \code{1 - (1.5 * missratio)}. If "MNAR", a similar
#' algorithm to the "MAR" condition is applied, but this time the principal
#' component is calculated from the columns specified by \code{missindex} instead
#' of the opposite.
#' @param missseed A seed to be set for the random selection of row indices to
#' set as missing for each simulated dataset. In order for this pattern to be
#' different for each dataset, the random seed for each iteration will be
#' \code{missseed} + the number of that iteration (i.e., \code{missseed + 1},
#' \code{missseed + 2}, etc.). The default of this argument is \code{NULL}, in
#' which case a random number from 1 to 1E6 is chosen, and again the iteration
#' number of each simulated dataset is added to that to set a new seed for each
#' new missingness pattern.
#' @param comiss A logical value. If \code{TRUE}, missingness will occur
#' simultaneously for all columns specified in \code{missindex} for a given row
#' index selected to have missingness, or if \code{FALSE}, each column will have
#' its own random row indices selected for missingness. For example, if
#' \code{missindex = c(1, 3)} and \code{ratiomiss = 0.4}, setting
#' \code{comiss = TRUE} would mean that a single random selection of 40% of the
#' rows would be randomly selected for a given simulated dataset, and those rows
#' would be \code{NA} for both columns 1 and 3. Setting \code{comiss = FALSE}
#' would mean that a new random selection of 40% of the rows is made for column 1
#' and then for column 3. Setting \code{comiss = TRUE} simulates participants
#' missing multiple tests within a given visit, whereas \code{comiss = FALSE}
#' simulates a more random missingness process independent of participant. This
#' defaults to \code{FALSE}.
#'
#' @return \code{GRCsim} returns a list of the following:
#' \item{DataList}{A list of simulated data frames generated by the function.}
#' \item{args}{The arguments passed to the function for future reference.}
#'
#' @import clusterGeneration FactoMineR
#' @export GRCsim
#'
#' @examples
#'
#' #This first example is a simple one that should run quickly
#'
#' simplesims <- GRCsim(nrep = 3)
#'
#' # These examples are drawn from the simulation conditions described in
#' # Day et al. 2024.
#'
#' #"Hub condition, low separation" from Day et al. 2024
#'
#' \dontrun{
#' hublowsep <- GRCsim(nDisClust = 4, nCohortClust = 4, ncontvars = 8,
#' ncatvars = 7, DisSepVal = 0.2, CohortSepVal = 0.2, catq = 0.8, nSignal = 15,
#' nNoise = 0, nOutliers = 0, nrep = 500, DisClustSizes = c(600, 200, 100, 100),
#' CohortClustSizes = c(400, 200, 300, 100), CDS = F, nContCDSrootvars = 2,
#' nCatCDSrootvars = 2, nContCDSgenvars = 3, nCatCDSgenvars = 3,
#' DisClustseed = 2, CohortClustseed = 3, CDSrho = 0.7)$DataList
#' }
#'
#' #"Common data source (CDS), medium separation" condition
#'
#' \dontrun{
#' cdsmedsep <- GRCsim(nDisClust = 4, nCohortClust = 4, ncontvars = 4,
#' ncatvars = 3, DisSepVal = 0.4, CohortSepVal = 0.2, catq = 0.8, nSignal = 7,
#' nNoise = 0, nOutliers = 0, nrep = 500, DisClustSizes = c(600, 200, 100, 100),
#' CohortClustSizes = c(400, 200, 300, 100), CDS = T, nContCDSrootvars = 2,
#' nCatCDSrootvars = 2, nContCDSgenvars = 3, nCatCDSgenvars = 3,
#' DisClustseed = 2, CohortClustseed = 3, CDSrho = 0.7)$DataList
#' }
#'
#' #"50% MAR, high separation, no comiss" condition
#'
#' \dontrun{
#' mar50high <- GRCsim(nDisClust = 4, nCohortClust = 4, ncontvars = 8,
#' ncatvars = 7, DisSepVal = 0.6, CohortSepVal = 0.2, catq = 0.8, nSignal = 15,
#' nNoise = 0, nOutliers = 0, nrep = 500, DisClustSizes = c(600, 200, 100, 100),
#' CohortClustSizes = c(400, 200, 300, 100), CDS = F, nContCDSrootvars = 2,
#' nCatCDSrootvars = 2, nContCDSgenvars = 3, nCatCDSgenvars = 3,
#' DisClustseed = 2, CohortClustseed = 3, CDSrho = 0.7, ratiomiss=0.5,
#' missindex=c(5:8, 13:15), misstype="MAR", missseed=10, comiss=F)$DataList
#' }
#'
#' @references
#' Day, D. B., LeWinn, K. Z., Karr, C. J., Loftus, C. T., Carroll, K. N., Bush,
#' N. R., ... & Sathyanarayana, S. (2024). Subpopulations of children with
#' multiple chronic health outcomes in relation to chemical exposures in the
#' ECHO-PATHWAYS consortium. Environment International, 185, 108486.
#'
#' Qiu, W., & Joe, H. (2006). Generation of random clusters with specified
#' degree of separation. Journal of Classification, 23(2), 315-334.
#'
#' Qiu, W., & Joe, H. (2006). Separation index and partial membership for
#' clustering. Computational statistics & data analysis, 50(3), 585-603.
#'
GRCsim <- function(nDisClust = 2, nCohortClust = 2, ncontvars = 2, ncatvars = 1,
                   DisSepVal = 0.3, CohortSepVal = 0.15, catq = 0.8,
                   nSignal = 3, nNoise = 0, nOutliers = 0, nrep = 50,
                   DisClustSizes = c(350, 150), CohortClustSizes = c(300, 200),
                   DisClustseed = 2, CohortClustseed = 3, CDS = F,
                   nContCDSrootvars = 1, nCatCDSrootvars = 1,
                   nContCDSgenvars = 2, nCatCDSgenvars = 2, CDSrho = 0.7,
                   ratiomiss = 0.2, missindex = NULL, misstype = "MCAR",
                   missseed = NULL, comiss = F){
  if(nDisClust != length(DisClustSizes)|nCohortClust != length(CohortClustSizes)){
    stop(paste0("There is a mismatch between the numbers of observations in",
                " each cluster and the number of clusters. Make sure that ",
                "nDisClust == length(DisClustSizes) and nCohortClust == ",
                "length(CohortClustSizes)."))
  }
  if(nNoise + nSignal != ncontvars + ncatvars){
    stop(paste0("The sum of nSignal and nNoise must equal the sum of ncontvars",
                " and ncatvars."))
  }
  cl <- match.call()

  set.seed(DisClustseed)
  grc.clusts <- genRandomClust(nDisClust, sepVal = DisSepVal,
                               numNonNoisy = nSignal, numNoisy = nNoise,
                               fileName = "grc.clust", numReplicate = nrep,
                               numOutlier = nOutliers, clustszind = 3,
                               clustSizes = DisClustSizes, outputDatFlag = F,
                               outputLogFlag = F, outputInfo = F)
  set.seed(CohortClustseed)
  grc.cohorts <- genRandomClust(nCohortClust, sepVal = CohortSepVal,
                                numNonNoisy = nSignal, numNoisy = nNoise,
                                fileName = "grc.cohort", numReplicate = nrep,
                                numOutlier = nOutliers, clustszind = 3,
                                clustSizes = CohortClustSizes, outputDatFlag = F,
                                outputLogFlag = F, outputInfo = F)
  combclusts <- list()
  if(CDS){
    for(i in 1:length(grc.clusts$datList)){
      combclusts[[i]] <- grc.clusts$datList[[i]] + grc.cohorts$datList[[i]]
      newseedstart <- DisClustseed + CohortClustseed * 100
      contCDS <- matrix(0, nrow(grc.clusts$datList[[i]]),
                        nContCDSgenvars * nContCDSrootvars)
      for(j in 1:nContCDSrootvars){
        for(k in 1:nContCDSgenvars){
          index <- (1 + (k-1)) + ((j-1) * nContCDSgenvars)
          set.seed(newseedstart + index)
          contCDS[, index] <- complement(combclusts[[i]][, j], CDSrho)
        }
      }; rm(j, k)
      catCDS <- matrix(0, nrow(grc.clusts$datList[[i]]),
                       nCatCDSgenvars * nCatCDSrootvars)
      newseedstart <- newseedstart * nCatCDSrootvars * nCatCDSgenvars
      for(j in (ncontvars + 1):(nCatCDSrootvars + ncontvars)){
        for(k in 1:nCatCDSgenvars){
          index <- (1 + (k-1)) + ((j-(1 + ncontvars)) * nCatCDSgenvars)
          set.seed(newseedstart + index)
          catCDS[, index] <- complement(combclusts[[i]][, j], CDSrho)
        }
      }; rm(j, k)
      contCDS <- cbind(contCDS, combclusts[[i]][
        , (nContCDSrootvars + 1):ncontvars])
      catCDS <- cbind(catCDS, combclusts[[i]][
        , (nCatCDSrootvars + 1):ncatvars])
      catCDS <- apply(catCDS, 2,
                      function(x) ifelse(x > quantile(x, probs = catq), 1, 0))
      combclusts[[i]] <- as.data.frame(cbind(contCDS, catCDS))
      for(k in c((ncol(contCDS) + 1):ncol(combclusts[[i]]))){
        combclusts[[i]][, k] <- as.factor(combclusts[[i]][, k])
        levels(combclusts[[i]][, k]) <- paste0("x", k, "=", 0:1)
      }; rm(k)
      names(combclusts[[i]]) <- paste0("x", 1:ncol(combclusts[[i]]))
      combclusts[[i]]$DiseaseState <- as.factor(grc.clusts$memList[[i]])
      levels(combclusts[[i]]$DiseaseState) <- paste0(
        "D", levels(combclusts[[i]]$DiseaseState))
      combclusts[[i]]$Cohort <- as.factor(grc.cohorts$memList[[i]])
      levels(combclusts[[i]]$Cohort) <- paste0(
        "C", levels(combclusts[[i]]$Cohort))
      combclusts[[i]]$DisCoh <- as.factor(interaction(
        combclusts[[i]]$DiseaseState, combclusts[[i]]$Cohort))
    }; rm(i)
  } else {
    for(i in 1:length(grc.clusts$datList)){
      combclusts[[i]] <- as.data.frame(grc.clusts$datList[[i]] +
                                         grc.cohorts$datList[[i]])
      names(combclusts[[i]]) <- paste0("x", 1:ncol(combclusts[[i]]))
      if(!is.null(missindex)){
        nonadf <- combclusts[[i]]
        library(FactoMineR)
        if(is.null(missseed)) missseed <- sample(1:1E6, 1)
        missseed <- missseed + i
        if(comiss){
          if(misstype == "MCAR"){
            set.seed(missseed)
            combclusts[[i]][
              sample(1:nrow(combclusts[[i]]),
                     size = floor(ratiomiss * nrow(combclusts[[i]])),
                     replace = F), missindex] <- NA
          } else if(misstype == "MAR"){
            newmissratio <- ratiomiss * 1.5
            nadriver <- combclusts[[i]][
              , grep("x", names(combclusts[[i]]))][, -missindex]
            napca <- PCA(nadriver, scale.unit = T, ncp = 5, graph = F)
            nadriver <- napca$ind$coord[, 1]
            set.seed(missseed)
            missppts <- sample(which(nadriver >= quantile(
              nadriver, probs = (1-newmissratio))),
              size = ratiomiss * nrow(combclusts[[i]]), replace = F)
            combclusts[[i]][missppts, missindex] <- NA
          } else if(misstype == "MNAR"){
            newmissratio <- ratiomiss * 1.5
            nadriver <- combclusts[[i]][, grep(
              "x", names(combclusts[[i]]))][, missindex]
            napca <- PCA(nadriver, scale.unit = T, ncp = 5, graph = F)
            nadriver <- napca$ind$coord[, 1]
            set.seed(missseed)
            missppts <- sample(which(nadriver >= quantile(
              nadriver, probs = (1-newmissratio))),
              size = ratiomiss * nrow(combclusts[[i]]), replace = F)
            combclusts[[i]][missppts, missindex] <- NA
          } else {stop("misstype must be one of 'MCAR', 'MAR', or 'MNAR'")}
        } else {
          if(misstype == "MCAR"){
            for(j in missindex){
              missseed <- missseed + j
              set.seed(missseed)
              combclusts[[i]][
                sample(1:nrow(combclusts[[i]]),
                       size = floor(ratiomiss * nrow(
                         combclusts[[i]])), replace = F), j] <- NA}
          } else if(misstype == "MAR"){
            newmissratio <- ratiomiss * 1.5
            nadriver <- combclusts[[i]][, grep(
              "x", names(combclusts[[i]]))][, -missindex]
            napca <- PCA(nadriver, graph = F)
            nadriver <- napca$ind$coord[, 1]
            for(j in missindex){
              missseed <- missseed + j
              set.seed(missseed)
              missppts <- sample(which(nadriver >= quantile(
                nadriver, probs = (1-newmissratio))),
                size = ratiomiss * nrow(combclusts[[i]]), replace = F)
              combclusts[[i]][missppts, j] <- NA
            }
          } else if(misstype == "MNAR"){
            newmissratio <- ratiomiss * 1.5
            nadriver <- combclusts[[i]][, grep(
              "x", names(combclusts[[i]]))][, missindex]
            napca <- PCA(nadriver, graph = F)
            nadriver <- napca$ind$coord[, 1]
            for(j in missindex){
              missseed <- missseed + j
              set.seed(missseed)
              missppts <- sample(which(nadriver >= quantile(
                nadriver, probs = (1 - newmissratio))),
                size = ratiomiss * nrow(combclusts[[i]]), replace = F)
              combclusts[[i]][missppts, j] <- NA
            }
          } else {stop("misstype must be one of 'MCAR', 'MAR', or 'MNAR'")}
        }
        catcols <- (((nSignal + nNoise) - ncatvars) + 1):(nSignal + nNoise)
        for(k in catcols){
          nonabin <- ifelse(nonadf[, k] > quantile(nonadf[, k], probs = catq), 1, 0)
          combclusts[[i]][which(!is.na(combclusts[[i]][, k])), k] <-
            nonabin[which(!is.na(combclusts[[i]][, k]))]
          combclusts[[i]][, k] <- as.factor(combclusts[[i]][, k])
          levels(combclusts[[i]][, k]) <-
            paste(names(combclusts[[i]])[k], levels(
              combclusts[[i]][, k]), sep = "=")
        };rm(k)
      } else {
        catcols <- (((nSignal + nNoise)-ncatvars) + 1):(nSignal + nNoise)
        for(k in catcols){
          combclusts[[i]][, k] <- as.factor(ifelse(
            combclusts[[i]][, k] > quantile(combclusts[[i]][, k],
                                            probs = catq), 1, 0))
          # levels(combclusts[[i]][, k]) <- paste(names(
          #   combclusts[[i]])[k], levels(combclusts[[i]][, k]), sep = "=")
        };rm(k)
      }

      combclusts[[i]]$DiseaseState <- as.factor(grc.clusts$memList[[i]])
      levels(combclusts[[i]]$DiseaseState) <- paste0(
        "D", levels(combclusts[[i]]$DiseaseState))
      combclusts[[i]]$Cohort <- as.factor(grc.cohorts$memList[[i]])
      levels(combclusts[[i]]$Cohort) <- paste0(
        "C", levels(combclusts[[i]]$Cohort))
      combclusts[[i]]$DisCoh <- as.factor(interaction(
        combclusts[[i]]$DiseaseState, combclusts[[i]]$Cohort))
    }; rm(i)
  }
  return(list(DataList = combclusts, args = cl))
}
