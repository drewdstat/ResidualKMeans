% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ClusterSummaryPlot.R
\name{ClusterSummaryPlot}
\alias{ClusterSummaryPlot}
\title{Visualize summaries of variables by cluster}
\usage{
ClusterSummaryPlot(
  data,
  clustvec,
  contvars,
  catvars,
  contgroups = NULL,
  catgroups = NULL,
  contwhitecutoff = NULL,
  catwhitecutoff = NULL,
  scale = T,
  contpalette = "viridis",
  catpalette = "plasma",
  palettealpha = 0.7,
  groupdiscpalette = "Set1",
  title = NULL,
  titlesize = 12,
  xlabelsize = 12,
  yaxistextsize = 10,
  xaxistextsize = 10,
  na.rm = T
)
}
\arguments{
\item{data}{This is a data frame containing columns for the continuous
variables (\code{contvars}) and categorical variables (\code{catvars}) to be
summarized by this function.}

\item{clustvec}{This is a character vector of cluster membership. This
should be of the same length as the number of rows (i.e., observations) in
\code{data}.}

\item{contvars}{This is a character vector of column names for continuous
variables in the data frame \code{data}.}

\item{catvars}{This is a character vector of column names for categorical
variables in the data frame \code{data}. These should be binary variables of
class \code{character}, \code{factor}, or \code{integer} with positive values
being equal to one of the following values:
\code{c(1, "y", "Y", "yes", "Yes", "YES")}. For categorical variables with >2
unique values, these shoudl be dummy encoded into binary variables.}

\item{contgroups}{An optional character vector of group names for the
\code{contvars} of the same length as \code{contvars}. This grouping is
shown in the output plot. If \code{contgroups} is provided, \code{catgroups}
must also be provided. This defaults to \code{NULL}, meaning that no
grouping of features is applied.}

\item{catgroups}{An optional character vector of group names for the
\code{catvars} of the same length as \code{catvars}. This grouping is
shown in the output plot. If \code{catgroups} is provided, \code{contgroups}
must also be provided. This defaults to \code{NULL}, meaning that no
grouping of features is applied.}

\item{contwhitecutoff}{An optional value on either the original scale of the
\code{contvars} or on a z-score scale (if \code{scale = TRUE}) above which
the font of the values displayed on the heatmap will be black and below which
or equal to which the font will be white. This is useful for seeing values
against a dark background. This defaults to \code{NULL}, meaning that all
text font will be black.}

\item{catwhitecutoff}{A similar optional value to \code{contwhitecutoff}, but
on the scale of 0 - 100 for the percentages of the binary categorical
variables.}

\item{contpalette}{The name of a viridis palette to apply to the continuous
variable summary heatmap (see \code{\link[ggplot2]{scale_colour_viridis_d}}
for palette names and
\href{https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html}{
the introductory vignette to viridis} to see the palettes). This defaults to
\code{"viridis"}.}

\item{catpalette}{Similar to \code{contpalette} but for the categorical
variable summary heatmap. This defaults to \code{"plasma"}.}

\item{palettealpha}{A value between 0 and 1 to scale the transparency of the
heatmap background fill colors. This defaults to 0.7.}

\item{groupdiscpalette}{If feature groups are defined, the heatmap will be
filled based on a discrete palette and both \code{contpalette} and
\code{catpalette} will be ignored. This can be the name of a palette
available through the package \code{RColorBrewer} (see
\code{\link[RColorBrewer]{display.brewer.all}}) or a custom palette function.
This defaults to \code{"Set1"}.}

\item{title}{An optional title to add to the plot. This defaults to
\code{NULL}, meaning that no title is applied.}

\item{titlesize}{The size of the title font if \code{title} is not
\code{NULL}. This defaults to \code{12}.}

\item{xlabelsize}{The font size of the x-axis title, which will be the word
"Cluster". This defaults to \code{12}.}

\item{yaxistextsize}{The font size of the text along the y-axis, which will
be the variable/feature names. This defaults to \code{10}.}

\item{xaxistextsize}{The font size of the x-axis text, which will be the
cluster names. This defaults to \code{10}.}

\item{na.rm}{This is a logical (boolean) value determining whether to remove
missing values from the total sample size (i.e., the denominator) when
calculating the percentages for each binary categorical variable. For
example, if there are 2 "yes" responses out of 10 total observations with 4
missing values, the percentage for that variable will be 20\% if
\code{na.rm = FALSE} and 33.3\% if \code{na.rm = TRUE}. This defaults to
\code{TRUE}.}
}
\value{
\code{ClusterSummaryPlot} returns a compound plot of class
\code{ggplot} consisting of two separate heatmaps for the continuous and
categorical variables.
}
\description{
\code{ClusterSummaryPlot} is a function to create a heatmap plot that
summarizes continuous and categorical variable data between clusters. This
function is meant to be used with the residual k-means method. The plot
consists of a heatmap separated vertically between the continuous variables
on top and the categorical variables below.
}
\examples{
# Generate simulated data, cluster it, and plot the results

#Single data frame of "Hub condition, medium separation" from Day et al. 2024

hubhighsep <- GRCsim(nDisClust = 4, nCohortClust = 4, ncontvars = 8,
ncatvars = 7, DisSepVal = 0.6, CohortSepVal = 0.2, catq = 0.8, nSignal = 15,
nNoise = 0, nOutliers = 0, nrep = 1, DisClustSizes = c(600, 200, 100, 100),
CohortClustSizes = c(400, 200, 300, 100), CDS = F, nContCDSrootvars = 2,
nCatCDSrootvars = 2, nContCDSgenvars = 3, nCatCDSgenvars = 3,
DisClustseed = 200, CohortClustseed = 300, CDSrho = 0.7)$DataList

clusters <- residkm(hubhighsep[[1]][, c(paste0("x", 1:15), "Cohort")],
groupcolumn = "Cohort", altfeatnames = paste0("Feature ", 1:15))

# residkm already creates one of these plots as part of its output
clusters$SummaryPlot

# We can revise the plot to group outcomes and add a custom palette

custompalette <- function(n) {
cols <- c("orange2", "deeppink3", "steelblue3", "forestgreen", "grey50",
"medium turquoise")
cols[1:n]
}

ClusterSummaryPlot(hubhighsep[[1]][, c(paste0("x", 1:15))],
clusters$Kmeans$cluster, paste0("x", 1:8), paste0("x", 9:15),
contgroups = rep(c("Resp", "Psych"), c(3, 5)),
catgroups = rep("History", 7), groupdiscpalette = custompalette)

}
