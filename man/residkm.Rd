% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/residkm.R
\name{residkm}
\alias{residkm}
\title{Residual k-means analysis}
\usage{
residkm(
  data,
  groupcolumn = "Cohort",
  krange = 2:10,
  ksel = T,
  altfeatnames = NULL,
  featgroups = NULL,
  impncp = 5,
  impgrouping = NULL,
  imptypes = NULL,
  method = c("kmeans", "pam", "spectral"),
  nbcindex = "all",
  nbcmethod = "complete",
  summaryplots = T
)
}
\arguments{
\item{data}{A data frame containing the \code{groupcolumn} column and all
variables/features to be clustered. This data frame should not include any
variables not intended to be included in the clustering.}

\item{groupcolumn}{A character value for the column name of the
grouping variable that represents known clustering structure that should be
removed from the clustering process. For example, this could be an identifier
for study cohort in a multi-cohort clustering analysis in which we want the
clustering to be independent of study cohort. This defaults to \code{"Cohort"}.}

\item{krange}{Either a single integer value or a vector of integers
representing the number of clusters (\code{k}) or a range of possible numbers
of clusters. Whether or not selection is done for this integer value or
vector is determined by the argument \code{ksel}. This defaults to \code{2:10}.}

\item{ksel}{A logical (boolean) value indicating whether to perform selection
for the number of clusters \code{k}. If \code{ksel} is \code{FALSE}, the
first value of \code{krange} is used as the number of clusters. If \code{ksel}
is \code{TRUE}, the consensus of algorithms used by the
\code{\link[NbClust]{NbClust}} function will be chosen as the number of
clusters. This defaults to \code{TRUE}.}

\item{altfeatnames}{An optional character vector of alternative names for the
features/variables included in the clustering. These names will replace the
corresponding column names in the output tables and plots. This defaults to
NULL.}

\item{featgroups}{This is an optional character vector defining a grouping of
features to be incorporated into the plots. This must be of the same length
as the number of features. This will define facets that will group features
together in the plots of cluster centers \code{CenterPlot} and in the summary
plot of features by cluster \code{SummaryPlot}. For example, if one is
clustering 4 self-reported features and 6 clinically measured features, one
could set \code{featgroups <- rep(c("Self-Reported", "Clinical"), c(4, 6))}.
This defaults to NULL, meaning that no grouping is applied in those plots.}

\item{impncp}{This and the following "imp..." arguments relate to the
MFA-based imputation procedure used if missing values are detected in the
provided data frame. Specifically, the \code{\link[missMDA]{imputeMFA}}
function is used for this imputation, and \code{impncp} refers to the number
of factors (akin to principal components) to use as a lower dimensional
representation of the data from which new values will be imputed. This
is the same as \code{ncp} in the \code{\link[missMDA]{imputeMFA}} functions,
and it defaults to 5.}

\item{impgrouping}{An optional vector of integers describing how many
variables are in each group if one wants to group variables for the MFA
procedure. For example, if there are 5 features included in the data frame
\code{data} and the middle 3 originate from a common source and are highly
correlated, one could group those 3 features for the imputation method by
setting \code{impgrouping} to \code{c(1, 3, 1)}. This is the same as the
\code{\link[missMDA]{imputeMFA}} argument \code{group}, and it defaults to
NULL, meaning that each variable is considered to be distinct and no features
are grouped together.}

\item{imptypes}{An optional vector to specify the variable types for each
group of features for the \code{\link[missMDA]{imputeMFA}} imputation
function. This must either be equal to the length of the number of clustering
features or, if \code{impgrouping} is specified, equal to the length of that
grouping vector. Available options are \code{"n"} for categorical variables,
\code{"c"} for continuous or integer values that will then be centered by
the function prior to MFA, or \code{"s"} for continuous or integer values
that will then be centered and scaled by the function prior to MFA. This is
identical to the \code{types} argument in
\code{\link[missMDA]{imputeMFA}}, and it defaults to NULL, meaning that each
continuous and integer variable will be set to type \code{"s"} and all
categorical variables will be set to type \code{"n"}.}

\item{method}{A character value showing which type of clustering method to
apply to the residuals of each variable regressed on \code{groupcolumn}. This
defaults to \code{"kmeans"}, which would implement the residual k-means
method and performed best out of all tested options of clustering algorithms
applied to the residuals in the
\href{https://pubmed.ncbi.nlm.nih.gov/38367551/}{Day et al. 2024 paper}.
However, alternative
options are included as a point of reference and for testing the residual
k-means algorithm for one's self against alternative methods. The first
alternative option is \code{"pam"} for partitioning around medoids (PAM),
which is implemented using the \code{\link[fpc]{pamk}} function. The second
is \code{"spectral"} for spectral clustering using the
\code{\link[fpc]{speccCBI}} function. For both PAM and spectral clustering,
the number of partitions is based on either the first value of \code{krange}
if \code{ksel} is \code{FALSE} or the most frequently chosen value from the
\code{\link[NbClust]{NbClust}} method, just as is the case with the default
k-means method (i.e., \code{method = "kmeans"}). It is not recommended to use
\code{"pam"} or \code{"spectral"} for \code{method} as they did not perform
as well in simulations as the default \code{"kmeans"} method.}

\item{nbcindex}{This character value argument is passed on to the
\code{index} argument of the \code{\link[NbClust]{NbClust}} method. This
chooses which algorithms to implement (see the \code{\link[NbClust]{NbClust}}
documentation for more details). This defaults to \code{"all"}.}

\item{nbcmethod}{This character value argument is passed on to the
\code{method} argument of the \code{\link[NbClust]{NbClust}} method. Popular
approaches include \code{"kmeans"} for k-means clustering and
\code{"complete"} for hierarchical clustering, which is the default
agglomeration method for \code{\link[base]{hclust}}. This defaults to
\code{"complete"} as this has performed well in my experience. It may be
counterintuitive that we would use a hierarchical clustering method for the
\code{\link[NbClust]{NbClust}} method and not the method \code{"kmeans"},
but that is because the implementation of k-means clustering in
\code{\link[NbClust]{NbClust}} method is flawed, always setting the seed to 1,
and only having one random initialization based on that same seed every time.
This can lead to bad initializations that improperly cluster the data, as is
clearly illustrated in this excellent
\href{https://davetang.org/muse/2019/01/23/the-golden-rule-of-bioinformatics/}{
2019 blog post by Dave Tang}. I would recommend comparing results when the
\code{nbcmethod} is set to \code{"complete"} and \code{"ward.D2"} to check
for consistency of your optimal number of clusters, and I would recommend
against using the \code{"kmeans"} \code{nbcmethod}.}

\item{summaryplots}{A logical (boolean) value indicating whether to include
the \code{CenterPlot}, \code{SummaryPlot}, and \code{CenterEuDist} plots
(see the description of the output below for more details). This defaults to
\code{TRUE}.}
}
\value{
\code{residkm} returns a list of class \code{"residkm"} that includes
the following:
\item{ResidualData}{The data frame of the residuals for each variable
regressed on \code{groupcolumn}. Note that these residuals are not
centered and scaled, though they were centered and scaled prior to
clustering.}
\item{Kmeans}{The output object of the k-means clustering of class
\code{"kmeans"}.}
\item{KChoice}{The output of the \code{\link[NbClust]{NbClust}} method.}
\item{CenterPlot}{A plot of the cluster centers on the scale of the z-scores
of the residuals. This is only output if \code{summaryplots = TRUE}.}
\item{SummaryPlot}{A plot of the summary statistics of each feature by
cluster. This is only output if \code{summaryplots = TRUE}.}
\item{CenterEuDist}{This is a plot showing the Euclidean distances between
each of the cluster centers. This is only output if \code{summaryplots = TRUE}.}
\item{ImpData}{This is the version of the dataset \code{data} but with the
singly imputed values included in cases where missing values are present in
the data frame. This only appears in the output list if missing values were
detected in the input data frame \code{data}.}
}
\description{
\code{residkm} performs residual k-means clustering, which is a method
developed to cluster mixed continuous and categorical data while controlling
for and thereby removing the influence of clustering by group. It was
designed for use in multi-cohort studies in which there will be clustering
by study site and different methods used at each site and cohort. The goal
of those studies is to treat the collection of different cohorts as if it
were one large cohort, and so this nuisance clustering by site/cohort must
be removed in some way. Residual k-means involves first regressing each
individual continuous or categorical variable on a grouping variable
(e.g., study site) and then performing k-means clustering on those residuals
after they are centered and scaled (i.e., having the mean subtracted and then
dividing by the standard deviation).
}
\details{
If there are missing data present in the matrix of variables to be clustered,
single-value, multifactor analysis (MFA)-based imputation is performed using
the \code{\link[missMDA]{imputeMFA}} function from the missMDA package. For
more information on this imputation approach, see this
\href{https://francoishusson.wordpress.com/2017/08/05/can-we-believe-in-the-imputations/}{
blog post from the package author}. The optimal number of clusters is either
user-specified or chosen using the consensus of methods implemented by the
\code{\link[NbClust]{NbClust}} function, with user-specified \code{method}
and \code{index} arguments fed into that function.
}
\examples{
# Creating simulated data with GRCsim and analyze it with residkm

#Single data frame of "Hub condition, medium separation" from Day et al. 2024

hubhighsep <- GRCsim(nDisClust = 4, nCohortClust = 4, ncontvars = 8,
ncatvars = 7, DisSepVal = 0.6, CohortSepVal = 0.2, catq = 0.8, nSignal = 15,
nNoise = 0, nOutliers = 0, nrep = 1, DisClustSizes = c(600, 200, 100, 100),
CohortClustSizes = c(400, 200, 300, 100), CDS = F,
DisClustseed = 200, CohortClustseed = 300, CDSrho = 0.7)$DataList

clusters <- residkm(hubhighsep[[1]][, c(paste0("x", 1:15), "Cohort")],
groupcolumn = "Cohort", altfeatnames = paste0("Feature ", 1:15),
featgroups = rep(c("Respiratory", "Behavior", "Disease\nHistory"), c(3, 5, 7)))

# Center and Summary Plots juxtaposed
cowplot::plot_grid(clusters$CenterPlot, clusters$SummaryPlot, nrow = 1)

# Plotting Euclidean distance between cluster centers
clusters$CenterEuDist()

# Seeing which combinations of algorithms chose which number of clusters (k)
clusters$KChoice$Best.nc

}
\references{
Day, D. B., LeWinn, K. Z., Karr, C. J., Loftus, C. T., Carroll, K. N., Bush,
N. R., ... & Sathyanarayana, S. (2024). Subpopulations of children with
multiple chronic health outcomes in relation to chemical exposures in the
ECHO-PATHWAYS consortium. Environment International, 185, 108486.

Hartigan, J. A. and Wong, M. A. (1979). Algorithm AS 136: A K-means
clustering algorithm. Applied Statistics, 28, 100–108. doi:10.2307/2346830.
}
